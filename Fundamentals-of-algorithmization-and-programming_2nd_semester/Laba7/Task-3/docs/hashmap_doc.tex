\UseRawInputEncoding
\documentclass[a4paper,12pt]{article}

% Packages for Russian language support and other formatting
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{hyperref}

% Document margins
\geometry{top=2cm, bottom=2cm, left=3cm, right=2cm}

% Code listing style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{cpp}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C++
}

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{3cm}
        {\LARGE \textbf{Документация по реализации хеш-таблицы на основе массивов стеков}}\\[1cm]
        {\large Техническая документация}\\[5cm]
        {\large \today}
    \end{center}
\end{titlepage}

\tableofcontents
\newpage

\section{Введение}

В данной документации описывается реализация хеш-таблицы на основе массивов стеков для учебных целей. Целью данной реализации является изучение базовых принципов работы хеш-таблиц и структур данных, а также приобретение практического опыта в программировании на C++.

Задача включает в себя разработку хеш-таблицы, которая:
\begin{itemize}
    \item Хранит пары ключ-значение с целочисленными ключами (хотя шаблон позволяет использовать и другие типы ключей)
    \item Использует массив фиксированного размера для хранения бакетов
    \item Разрешает коллизии с помощью стеков, реализованных с использованием собственной структуры данных \texttt{Deque<Entry>}
    \item Обеспечивает базовые операции вставки (\texttt{Insert}), удаления (\texttt{Remove}) и поиска (\texttt{Find})
    \item Не использует стандартные контейнеры STL или библиотеку Boost
\end{itemize}

Данная реализация, несмотря на академический характер, глубоко демонстрирует внутреннее устройство хеш-таблиц, влияние выбора стратегии разрешения коллизий на производительность и процесс создания структур данных без использования стандартных библиотек.

\section{Структура проекта и основные компоненты}

Проект состоит из следующих основных компонентов:

\subsection{Namespace sml}

Все классы, связанные с хеш-таблицей и используемыми вспомогательными структурами, находятся в пространстве имен \texttt{sml} (Simple Library). Это обеспечивает логическую группировку, позволяет избежать конфликтов имен в глобальной области видимости и способствует инкапсуляции.

\subsection{Класс Deque<T>}

Класс \texttt{sml::Deque<T>} представляет собой двухстороннюю очередь (дек), которая в данной реализации используется преимущественно как контейнер для хранения элементов (пар ключ-значение \texttt{Entry}) внутри бакетов хеш-таблицы. Несмотря на свою природу дека, в контексте хеш-таблицы он функционирует как стек или список для обработки коллизий. Дек реализован с использованием внутреннего массива бакетов фиксированного размера, что обеспечивает эффективность доступа по индексу.

Основные методы класса \texttt{Deque<T>} (применительно к его использованию в HashMap):
\begin{itemize}
    \item \texttt{push\_back(const T\& value)} --- добавляет элемент в конец дека (используется для добавления новых записей при коллизии)
    \item \texttt{pop\_back()} --- удаляет элемент из конца дека
    \item \texttt{front()} --- возвращает ссылку на первый элемент дека
    \item \texttt{back()} --- возвращает ссылку на последний элемент дека
    \item \texttt{operator[](size\_t idx)} --- обеспечивает прямой доступ к элементу по индексу, что критически важно для быстрого поиска и итерации по элементам в бакете
    \item \texttt{size()} --- возвращает текущее количество элементов в деке
    \item \texttt{empty()} --- проверяет, пуст ли дек
\end{itemize}
Использование дека, а не более простой структуры вроде связанного списка или массива, обусловлено задачей реализации "стека через дек", хотя в HashMap мы пользуемся скорее его возможностью эффективной итерации и доступа по индексу.

\subsection{Класс HashMap<Key, Value>}

Класс \texttt{sml::HashMap<Key, Value>} является центральным компонентом и представляет собой реализацию хеш-таблицы. Он использует массив указателей на \texttt{Deque<Entry>} в качестве бакетов для разрешения коллизий методом цепочек.

\subsubsection{Внутренняя структура}

Структура класса определена следующим образом:

\begin{lstlisting}[style=cpp]
template <typename Key, typename Value>
class HashMap {
 public:
  // Constructor
  explicit HashMap(int size = 10) : size_(size) {
    // Инициализация массива указателей на деки
    buckets_ = new Deque<Entry>[size_];
  }
  
  // Destructor
  ~HashMap() {
    // Освобождение памяти, выделенной под массив бакетов
    delete[] buckets_;
  }
  
  // ...методы...
  
 protected:
  // Внутренняя структура для хранения пары ключ-значение
  struct Entry {
    Key key;
    Value value;
    
    Entry(const Key& k, const Value& v) : key(k), value(v) {}
    
    // Оператор сравнения для удобства поиска
    bool operator==(const Entry& other) const {
        return key == other.key;
    }
  };
  
  // Массив бакетов. Каждый бакет - это Deque<Entry>, 
  // хранящий элементы, хеши которых попали в этот бакет.
  Deque<Entry>* buckets_;
  // Размер массива бакетов (фиксированный)
  int size_;
  
 private:
  // Хеш-функция для преобразования ключа в индекс бакета
  int Hash(const Key& key) const {
    // Используется стандартная хеш-функция C++
    return std::hash<Key>{}(key) % size_;
  }
};
\end{lstlisting}

Основные внутренние элементы класса:
\begin{itemize}
    \item \texttt{buckets\_}: Динамически выделяемый массив объектов \texttt{Deque<Entry>}. Каждый элемент этого массива является отдельным "бакетом", который может содержать ноль или более пар \texttt{Entry}, хешированных к этому индексу.
    \item \texttt{size\_}: Целочисленное значение, представляющее фиксированный размер массива бакетов. Этот размер устанавливается при создании объекта \texttt{HashMap} и не изменяется в течение его жизни (в текущей реализации).
    \item \texttt{Entry}: Вложенная структура, агрегирующая ключ (\texttt{Key}) и значение (\texttt{Value}) в одну логическую единицу. Добавлен оператор сравнения \texttt{operator==} для удобства поиска внутри дека.
    \item \texttt{Hash}: Приватный метод для вычисления индекса бакета по заданному ключу. Он использует стандартную хеш-функцию \texttt{std::hash} для получения хеша ключа, а затем применяет операцию по модулю \texttt{size\_}, чтобы отобразить хеш на диапазон индексов массива бакетов \([0, size\_ - 1]\).
\end{itemize}

\subsubsection{Основные методы}

\begin{itemize}
    \item \texttt{Insert(const Key\& key, const Value\& value)}: Вставляет новую пару ключ-значение или обновляет значение, если ключ уже существует.
    \item \texttt{Remove(const Key\& key)}: Удаляет запись, соответствующую заданному ключу.
    \item \texttt{Find(const Key\& key)}: Ищет значение по заданному ключу, возвращая указатель на значение или \texttt{nullptr}, если ключ не найден.
    \item \texttt{GetSize()}: Возвращает размер массива бакетов (\texttt{size\_}).
    \item \texttt{GetBucketSize(int bucket\_index)}: Возвращает количество элементов в конкретном бакете.
    \item \texttt{GetKeyAt(int bucket\_index, size\_t position)}: Возвращает ключ элемента по указанной позиции внутри дека конкретного бакета. Требует проверки границ.
    \item \texttt{GetAllKeys()}: (Предполагаемый метод) Должен собирать и возвращать список всех ключей, хранящихся в хеш-таблице. (В предоставленном коде отсутствует реализация этого метода, но он упомянут в списке).
    \item \texttt{Print(OutputFunc output)}: Выводит содержимое хеш-таблицы, итерируя по бакетам и элементам в каждом деке, используя предоставленную функцию вывода.
\end{itemize}

\section{Подробный анализ методов и их реализация}

\subsection{Метод Insert}

Метод \texttt{Insert} реализует логику добавления новой записи или обновления существующей.

\begin{lstlisting}[style=cpp]
void Insert(const Key& key, const Value& value) {
  // 1. Вычисляем индекс бакета для данного ключа.
  int index = Hash(key);
  
  // 2. Ищем запись с таким же ключом в соответствующем бакете (Deque).
  bool found = false;
  
  // Итерация по элементам дека бакета.
  for (size_t i = 0; i < buckets_[index].size(); ++i) {
    if (buckets_[index][i].key == key) {
      // 3a. Если ключ найден, обновляем существующее значение и отмечаем, что элемент найден.
      buckets_[index][i].value = value;
      found = true;
      break; // Прерываем поиск, так как ключ уникален в бакете
    }
  }
  
  // 3b. Если ключ не найден в бакете после полного прохода...
  if (!found) {
    // Создаем новую запись и добавляем ее в конец дека бакета.
    buckets_[index].push_back(Entry(key, value));
  }
}
\end{lstlisting}

\begin{enumerate}
    \item Вычисляется индекс бакета, используя хеш-функцию \texttt{Hash(key)}.
    \item Происходит линейный поиск по элементам внутри дека \texttt{buckets\_[index]} для проверки наличия записи с совпадающим ключом.
    \item Если запись найдена, ее значение обновляется (\texttt{buckets\_[index][i].value = value}).
    \item Если линейный поиск завершился, а ключ не был найден (\texttt{!found}), создается новая структура \texttt{Entry} с заданными ключом и значением, и она добавляется в конец дека с помощью \texttt{push\_back}.
\end{enumerate}

Временная сложность метода \texttt{Insert}:
\begin{itemize}
    \item \textbf{Средний случай:} $O(1)$. При равномерном распределении ключей по бакетам, средний размер дека (\texttt{buckets\_[index].size()}) мал и стремится к константе (load factor). Линейный поиск по небольшому количеству элементов занимает константное время.
    \item \textbf{Худший случай:} $O(n)$, где $n$ --- общее количество элементов в хеш-таблице. Это происходит в случае крайне неудачной хеш-функции, когда все ключи хешируются в один и тот же бакет. Тогда поиск и вставка в этот бакет требуют времени, пропорционального количеству элементов в нем, которое может достигать $n$.
\end{itemize}

Пространственная сложность: $O(k + n)$, где $k$ --- размер массива бакетов (\texttt{size\_}), $n$ --- общее количество элементов. Память выделяется под массив деков и под хранение элементов внутри этих деков.

\subsection{Метод Remove}

Метод \texttt{Remove} предназначен для удаления записи по ключу.

\begin{lstlisting}[style=cpp]
bool Remove(const Key& key) {
  // 1. Вычисляем индекс бакета.
  int index = Hash(key);
  
  // 2. Ищем запись с заданным ключом в соответствующем бакете.
  for (size_t i = 0; i < buckets_[index].size(); ++i) {
    if (buckets_[index][i].key == key) {
      // 3. Если запись найдена, создаем временный дек.
      Deque<Entry> temp;
      
      // 4. Копируем в него все элементы из исходного дека, кроме удаляемого.
      for (size_t j = 0; j < buckets_[index].size(); ++j) {
        if (j != i) { // Пропускаем элемент с индексом i (удаляемый)
          temp.push_back(buckets_[index][j]);
        }
      }
      
      // 5. Заменяем исходный дек в бакете временным деком, используя семантику перемещения.
      buckets_[index] = std::move(temp);
      
      // 6. Возвращаем true, сигнализируя об успешном удалении.
      return true;
    }
  }
  
  // 7. Если после полного прохода по бакету ключ не найден, возвращаем false.
  return false;
}
\end{lstlisting}

\begin{enumerate}
    \item Вычисляется индекс бакета для заданного ключа.
    \item Производится линейный поиск элемента с совпадающим ключом в соответствующем деке.
    \item Если элемент найден, создается новый временный объект \texttt{Deque<Entry>}.
    \item Все элементы из исходного дека, кроме того, который нужно удалить (с индексом \texttt{i}), копируются во временный дек. Это потенциально неэффективная операция, требующая итерации по всему деку и копирования/перемещения элементов.
    \item Исходный дек в бакете (\texttt{buckets\_[index]}) заменяется временным деком с использованием \texttt{std::move} для избежания лишнего копирования данных самого дека (но не элементов внутри него).
    \item Метод возвращает \texttt{true}, если элемент был найден и удален.
    \item Если элемент не найден после полного прохода, метод возвращает \texttt{false}.
\end{enumerate}

Временная сложность метода \texttt{Remove}:
\begin{itemize}
    \item \textbf{Средний случай:} $O(L)$, где $L$ --- средний размер бакета (load factor). Поиск занимает $O(L)$, а создание временного дека и копирование элементов --- также $O(L)$. Суммарно $O(L)$, что при хорошей хеш-функции и низком load factor близко к $O(1)$.
    \item \textbf{Худший случай:} $O(n)$, где $n$ --- общее количество элементов. Если все элементы находятся в одном бакете, поиск занимает $O(n)$, а копирование элементов в новый дек --- также $O(n)$.
\end{itemize}

\subsection{Метод Find}

Метод \texttt{Find} ищет значение, связанное с заданным ключом.

\begin{lstlisting}[style=cpp]
Value* Find(const Key& key) {
  // 1. Вычисляем индекс бакета.
  int index = Hash(key);
  
  // 2. Ищем запись с заданным ключом в соответствующем бакете.
  for (size_t i = 0; i < buckets_[index].size(); ++i) {
    if (buckets_[index][i].key == key) {
      // 3. Если запись найдена, возвращаем указатель на ее значение.
      return &(buckets_[index][i].value);
    }
  }
  
  // 4. Если ключ не найден после полного прохода по бакету, возвращаем nullptr.
  return nullptr;
}
\end{lstlisting}

\begin{enumerate}
    \item Вычисляется индекс бакета для заданного ключа.
    \item Производится линейный поиск элемента с совпадающим ключом в соответствующем деке.
    \item Если элемент найден, возвращается указатель на поле \texttt{value} найденной структуры \texttt{Entry}. Возврат указателя позволяет модифицировать значение "на месте", а также сигнализировать о наличии или отсутствии элемента (\texttt{nullptr}).
    \item Если после полного прохода по деку элемент не найден, возвращается \texttt{nullptr}.
\end{enumerate}

Временная сложность метода \texttt{Find}:
\begin{itemize}
    \item \textbf{Средний случай:} $O(L)$, где $L$ --- средний размер бакета (load factor). При равномерном распределении и низком load factor это близко к $O(1)$.
    \item \textbf{Худший случай:} $O(n)$, где $n$ --- общее количество элементов. Возникает при сильных коллизиях, когда все элементы находятся в одном бакете, требуя линейного поиска по всем элементам.
\end{itemize}

\subsection{Метод Print}

Метод \texttt{Print} предоставляет способ визуализации текущего состояния хеш-таблицы.

\begin{lstlisting}[style=cpp]
template <typename OutputFunc>
void Print(OutputFunc output) {
  output("Hash Map Contents:");
  
  // Итерация по всем бакетам.
  for (int i = 0; i < size_; ++i) {
    // Формируем строку для текущего бакета.
    std::string bucket_str = "Bucket " + std::to_string(i) + ": [";
    
    // Итерация по элементам внутри дека текущего бакета.
    for (size_t j = 0; j < buckets_[i].size(); ++j) {
      // Добавляем ключ текущего элемента к строке.
      bucket_str += std::to_string(buckets_[i][j].key);
      // Добавляем разделитель между ключами, если это не последний элемент.
      if (j < buckets_[i].size() - 1) {
        bucket_str += ", ";
      }
    }
    
    bucket_str += "]";
    // Выводим строку бакета, используя предоставленную функцию вывода.
    output(bucket_str);
  }
  
  output(""); // Пустая строка для завершения вывода
}
\end{lstlisting}

\begin{enumerate}
    \item Метод принимает шаблонный параметр \texttt{OutputFunc}, что делает его гибким для вывода в различные потоки или логгеры.
    \item Он итерирует по всем бакетам от 0 до \texttt{size\_ - 1}.
    \item Для каждого бакета формируется строка, включающая его индекс и список ключей всех \texttt{Entry} структур, хранящихся в соответствующем деке.
    \item Для доступа к ключам используется прямой доступ по индексу \texttt{buckets\_[i][j].key}, что возможно благодаря реализации \texttt{operator[]} в классе \texttt{Deque}.
    \item Сформированная строка выводится с помощью функции \texttt{output}.
\end{enumerate}

Временная сложность метода \texttt{Print}: $O(k + n)$, где $k$ --- размер массива бакетов (\texttt{size\_}), а $n$ --- общее количество элементов во всех бакетах. Это связано с необходимостью итерации по всем бакетам и всем элементам внутри каждого бакета.

\section{Хеш-функция}

Хеш-функция является фундаментальной частью любой хеш-таблицы. Ее основная задача --- преобразовать ключ произвольного типа (\texttt{Key}) в целое число (хеш-код), которое затем используется для определения индекса бакета. Качество хеш-функции напрямую влияет на производительность хеш-таблицы: хорошая хеш-функция минимизирует коллизии (случаи, когда разные ключи хешируются в один и тот же индекс бакета), обеспечивая равномерное распределение элементов.

В данной реализации используется простая хеш-функция:

\begin{lstlisting}[style=cpp]
int Hash(const Key& key) const {
  // 1. Получение хеш-кода с помощью стандартной функции.
  // 2. Применение операции по модулю для получения индекса бакета.
  return std::hash<Key>{}(key) % size_;
}
\end{lstlisting}

\begin{enumerate}
    \item Для получения исходного хеш-кода используется шаблон класса \texttt{std::hash<Key>}. Этот класс является частью стандартной библиотеки C++ (\texttt{<functional>}) и предоставляет специализации для основных встроенных типов (целые числа, строки, указатели и т.д.), а также может быть специализирован пользователем для своих типов. Стандартные специализации \texttt{std::hash} стремятся обеспечить хорошее, хотя и не всегда криптографически стойкое, распределение хеш-кодов.
    \item Полученный хеш-код затем преобразуется в индекс бакета путем взятия остатка от деления на размер массива бакетов (\texttt{size\_}). Операция по модулю \texttt{\% size\_} гарантирует, что результат будет находиться в допустимом диапазоне индексов от \(0\) до \texttt{size\_ - 1}.
\end{enumerate}

Для целочисленных ключей (\texttt{int}, \texttt{long} и т.д.), стандартная \texttt{std::hash} обычно возвращает само значение ключа или его битовые преобразования. Применение операции по модулю к этим значениям обеспечивает относительно равномерное распределение по бакетам, *при условии, что размер таблицы (\texttt{size\_}) не является степенью двойки*, особенно для целочисленных ключей, которые могут демонстрировать паттерны в младших битах. Если \texttt{size\_} является степенью двойки, хеш-функция будет зависеть только от младших битов хеш-кода, что может привести к неравномерному распределению, если ключи имеют схожие младшие биты. Выбор простого числа в качестве \texttt{size\_} обычно предпочтительнее.

Использование \texttt{std::hash} удобно, так как она уже реализована для стандартных типов и может быть расширена. Однако для специфических задач с особым распределением ключей или повышенными требованиями к минимизации коллизий, возможно, потребуется разработка собственной, более сложной хеш-функции.

\section{Особенности реализации и проектные решения}

Данная реализация хеш-таблицы включает несколько специфических проектных решений, которые отличают ее от стандартных контейнеров и других возможных подходов.

\subsection{Использование массива фиксированного размера для бакетов}

Ключевой особенностью является использование массива \texttt{Deque<Entry>*} фиксированного размера (\texttt{size\_}) для хранения бакетов. Размер этого массива определяется при создании объекта \texttt{HashMap} и не может быть изменен в дальнейшем (в текущей реализации, хотя раздел расширений описывает потенциальный механизм изменения размера).

\textbf{Преимущества:}
\begin{itemize}
    \item \textbf{Простота реализации:} Управление памятью и индексами упрощается, так как размер массива известен и постоянен.
    \item \textbf{Быстрый доступ к бакетам:} Доступ к конкретному бакету \texttt{buckets\_[index]} занимает константное время \(O(1)\), так как это простой индексированный доступ к элементу массива.
    \item \textbf{Отсутствие накладных расходов на изменение размера:} В отличие от динамически расширяемых хеш-таблиц, здесь нет операций рехеширования, которые могут быть дорогостоящими.
\end{itemize}

\textbf{Недостатки:}
\begin{itemize}
    \item \textbf{Ограниченная масштабируемость:} Производительность может существенно деградировать при увеличении количества элементов, если оно значительно превышает размер массива бакетов. Рост коэффициента заполнения (load factor = количество элементов / размер таблицы) приводит к увеличению среднего размера дека в бакетах и, соответственно, к увеличению времени выполнения операций \texttt{Insert}, \texttt{Remove}, \texttt{Find} в среднем случае.
    \item \textbf{Необходимость выбора оптимального размера заранее:} Выбор слишком маленького размера приведет к частым коллизиям и низкой производительности. Выбор слишком большого размера приведет к неэффективному использованию памяти. Оптимальный размер зависит от ожидаемого количества элементов и желаемого коэффициента заполнения.
    \item \textbf{Отсутствие автоматического роста:} Пользователь должен заранее знать или оценить максимальное количество элементов для выбора адекватного размера таблицы.
\end{itemize}

\subsection{Реализация стратегии разрешения коллизий с помощью Deque}

Для разрешения коллизий, т.е. ситуаций, когда два или более разных ключа хешируются в один и тот же индекс бакета, используется метод \textbf{цепочек (separate chaining)}. В этой реализации каждая "цепочка" (список элементов, попавших в один бакет) представлена объектом \texttt{sml::Deque<Entry>}.

В стандартных реализациях хеш-таблиц с методом цепочек обычно используются связанные списки (\texttt{std::forward\_list}, \texttt{std::list}) или динамические массивы (\texttt{std::vector}). Использование именно \texttt{sml::Deque} в данном проекте, по-видимому, связано с учебной задачей по реализации стека через дек и последующим применением этой структуры.

\textbf{Как Deque используется для разрешения коллизий:}
Когда новый элемент вставляется (\texttt{Insert}) и его ключ хешируется в бакет \texttt{index}, код итерирует по *существующим* элементам в \texttt{buckets\_[index]}. Если ключ уже присутствует, значение обновляется. Если ключ уникален в этом бакете, новая запись \texttt{Entry} добавляется в *конец* дека с помощью \texttt{push\_back}. Таким образом, дек используется как обычный список, куда новые элементы при коллизии просто "добавляются в конец цепочки". Операции поиска и удаления требуют линейного сканирования элементов в соответствующем деке.

\textbf{Сравнение с другими структурами для цепочек:}
\begin{itemize}
    \item \textbf{Связанный список (например, \texttt{std::forward\_list}):} Добавление в начало \(O(1)\), удаление элемента после найденного \(O(1)\) (если итератор указывает на предыдущий элемент), поиск \(O(L)\). Простой связанный список не позволяет эффективный доступ по индексу.
    \item \textbf{Динамический массив (\texttt{std::vector}):} Добавление в конец \(O(1)\) в среднем (с возможными перевыделениями), доступ по индексу \(O(1)\), поиск \(O(L)\), удаление из середины \(O(L)\) (требует сдвига элементов). \texttt{std::vector} обеспечивает хороший доступ по индексу, что удобно для итерации и поиска.
    \item \textbf{Дек (\texttt{sml::Deque}):} В данной реализации, похоже, используется в основном как список с возможностью эффективного доступа по индексу благодаря внутренней реализации на основе массива бакетов дека. Это дает преимущество в простоте итерации и поиска по сравнению со связанным списком, но удаление из середины все еще требует перестройки дека (как показано в методе \texttt{Remove}).
\end{itemize}
Выбор \texttt{sml::Deque}, вероятно, продиктован требованием использовать разработанную структуру, демонстрируя, что дек может быть базой для других реализаций, даже если для конкретной задачи (цепочки коллизий) более стандартным выбором мог бы быть \texttt{std::vector} или \texttt{std::list}.

\subsection{Отказ от стандартных контейнеров STL и библиотеки Boost}

Принципиальным решением при разработке было не использовать готовые контейнеры из стандартной библиотеки C++ (STL), такие как \texttt{std::vector}, \texttt{std::list}, \texttt{std::unordered\_map}, или структуры из библиотеки Boost.

\textbf{Обоснование:}
\begin{itemize}
    \item \textbf{Учебные цели:} Главной целью является глубокое понимание принципов работы структур данных путем их самостоятельной реализации. Это включает управление памятью, реализацию алгоритмов вставки, удаления, поиска и обработку специфических ситуаций, таких как коллизии.
    \item \textbf{Контроль над реализацией:} Самостоятельная реализация дает полный контроль над деталями низкого уровня, позволяя адаптировать структуру данных под очень специфические требования или оптимизировать ее поведение.
    \item \textbf{Минимизация зависимостей:} Проект не зависит от наличия и версии внешних библиотек (кроме стандартной библиотеки C++), что упрощает сборку и распространение.
    \item \textbf{Демонстрация навыков:} Разработка с нуля демонстрирует способность инженера создавать сложные структуры данных и алгоритмы.
\end{itemize}
Хотя использование STL или Boost значительно ускорило бы разработку и, скорее всего, обеспечило бы более оптимизированные и протестированные реализации, отказ от них оправдан в контексте учебного проекта, ориентированного на понимание основ.

\section{Сравнение с std::unordered\_map (STL)}

\texttt{std::unordered\_map} является стандартной реализацией хеш-таблицы в C++ и предоставляет ассоциативный контейнер, который хранит элементы в виде пар ключ-значение с уникальными ключами. Сравним вашу реализацию \texttt{sml::HashMap} с \texttt{std::unordered\_map}.

\textbf{sml::HashMap:}
\begin{itemize}
    \item \textbf{Базовая структура:} Массив фиксированного размера \texttt{size\_} указателей на \texttt{sml::Deque<Entry>}.
    \item \textbf{Разрешение коллизий:} Метод цепочек, где каждая цепочка реализована с помощью \texttt{sml::Deque}. Поиск и удаление в цепочке --- линейное сканирование дека.
    \item \textbf{Хеш-функция:} Использует \texttt{std::hash<Key>} с последующей операцией по модулю \texttt{size\_}. Размер таблицы фиксирован, что может привести к проблемам с распределением, если \texttt{size\_} не выбрано оптимально (например, степень двойки).
    \item \textbf{Изменение размера:} Не поддерживается в базовой реализации (но обсуждается как расширение). Фиксированный размер означает, что коэффициент заполнения растет с увеличением количества элементов, что ухудшает производительность при высоком заполнении.
    \item \textbf{Производительность:} Среднее время операций \texttt{Insert}, \texttt{Remove}, \texttt{Find} --- $O(L)$, где $L$ --- средний размер бакета (load factor). В худшем случае --- $O(n)$, где $n$ --- количество элементов (все в одном бакете). Операция \texttt{Remove} потенциально неэффективна из-за создания временного дека.
    \item \textbf{Гибкость ключей/значений:} Поддерживает любые типы \texttt{Key} и \texttt{Value}, для которых определена \texttt{std::hash} (для \texttt{Key}).
    \item \textbf{Итерация:} Не поддерживает стандартные итераторы STL. Итерация по всем элементам возможна через обход бакетов и деков вручную или через метод \texttt{Print}.
    \item \textbf{Управление памятью:} Ручное управление массивом бакетов (\texttt{new}/\\texttt{delete[]}). Управление памятью внутри \texttt{sml::Deque} зависит от его реализации.
    \item \textbf{Особенности реализации:} Использование \texttt{sml::Deque} для цепочек, что отличается от типичных реализаций.
\end{itemize}

\textbf{std::unordered\_map:}
\begin{itemize}
    \item \textbf{Базовая структура:} Обычно реализуется как массив указателей на начало цепочек. Сами цепочки могут быть реализованы по-разному в зависимости от конкретной реализации STL (например, связанные списки или узлы с указателями).
    \item \textbf{Разрешение коллизий:} Метод цепочек. Добавление в цепочку обычно $O(1)$. Поиск и удаление в цепочке --- линейное сканирование.
    \item \textbf{Хеш-функция:} Использует \texttt{std::hash<Key>}. Реализации STL могут применять дополнительные преобразования к результату \texttt{std::hash} для лучшего распределения, а также используют более сложные функции отображения хеша на индекс, чем просто операция по модулю (например, с использованием битовых операций), особенно при изменении размера таблицы.
    \item \textbf{Изменение размера (Rehashing):} Автоматически изменяет размер массива бакетов (обычно удваивает его) при достижении определенного коэффициента заполнения (load factor), чтобы поддерживать среднее время операций близким к $O(1)$. Операция рехеширования требует пересчета хеша для всех существующих элементов и их перемещения в новые бакеты, что является дорогостоящей операцией $O(n)$.
    \item \textbf{Производительность:} Среднее время операций \texttt{insert}, \texttt{erase}, \texttt{find} --- $O(1)$, при условии хорошей хеш-функции и эффективного механизма рехеширования, поддерживающего низкий load factor. В худшем случае (все элементы в одном бакете) --- $O(n)$.
    \item \textbf{Гибкость ключей/значений:} Поддерживает любые типы \texttt{Key} и \texttt{Value}, для которых определены \texttt{std::hash} (для \texttt{Key}) и оператор сравнения на равенство (\texttt{operator==} для \texttt{Key}, необходим для поиска внутри цепочки).
    \item \textbf{Итерация:} Поддерживает двунаправленные итераторы, позволяя обходить все элементы контейнера. Порядок обхода элементов не гарантируется (неупорядоченная карта).
    \item \textbf{Управление памятью:} Автоматическое управление памятью. Контейнер сам выделяет и освобождает память по мере необходимости, включая операции рехеширования.
    \item \textbf{Особенности реализации:} Оптимизированные внутренние механизмы, использование стандартных алгоритмов и структур данных.
\end{itemize}

\textbf{Вывод:}
Ваша \texttt{sml::HashMap} является упрощенной учебной реализацией хеш-таблицы с методом цепочек и фиксированным размером. Она хорошо демонстрирует базовые принципы, но имеет ограничения по масштабируемости и производительности по сравнению со стандартом \texttt{std::unordered\_map}, которая является более зрелой, оптимизированной и динамически управляемой структурой данных, предназначенной для широкого спектра задач. Основные отличия заключаются в механизме изменения размера, деталях реализации цепочек (ваш \texttt{sml::Deque} против внутренних структур STL) и общем уровне оптимизации.

\section{Альтернативные стратегии разрешения коллизий}

Метод цепочек, используемый в данной реализации, является одной из основных стратегий разрешения коллизий. Существуют и другие подходы:

\subsection{Открытая адресация (Open Addressing)}

Вместо использования отдельных списков для каждого бакета, при открытой адресации все элементы хранятся непосредственно в массиве бакетов. При возникновении коллизии (когда целевой бакет уже занят), алгоритм ищет следующий доступный слот в массиве, используя различные стратегии пробирования:
\begin{itemize}
    \item \textbf{Линейное пробирование (Linear Probing):} Поиск следующего слота осуществляется путем последовательного сканирования массива с фиксированным шагом (обычно 1). \( \text{next\_index} = (\text{current\_index} + \text{step}) \% \text{size} \). Может страдать от "первичной кластеризации", когда занятые слоты образуют большие группы, увеличивая время поиска.
    \item \textbf{Квадратичное пробирование (Quadratic Probing):} Шаг увеличивается квадратично с каждой попыткой. \( \text{next\_index} = (\text{current\_index} + \text{step}^2) \% \text{size} \). Помогает уменьшить первичную кластеризацию, но может страдать от "вторичной кластеризации".
    \item \textbf{Двойное хеширование (Double Hashing):} Для определения шага используется вторая хеш-функция. \( \text{next\_index} = (\text{current\_index} + \text{step} \times \text{hash}_2(\text{key})) \% \text{size} \). Обеспечивает более равномерное распределение при поиске свободного слота.
\end{itemize}
При открытой адресации операции удаления могут быть сложнее, так как простое удаление элемента может нарушить последовательность поиска для других элементов, которые столкнулись с ним при вставке. Часто используются "ленивые" удаления (пометка слота как удаленного). Открытая адресация требует, чтобы load factor был меньше 1 (обычно значительно меньше, например, < 0.7), чтобы гарантировать нахождение свободного слота и поддерживать производительность.

\subsection{Хеширование с цепочками на основе других структур}

Вместо простых списков, в качестве цепочек могут использоваться другие структуры данных для ускорения поиска и удаления внутри бакета, особенно при высоком load factor:
\begin{itemize}
    \item \textbf{Сбалансированные бинарные деревья поиска (например, красно-черные деревья):} Каждая цепочка является деревом, хранящим элементы, хешированные в данный бакет, упорядоченные по ключу. Вставка, поиск и удаление в таком дереве занимает \(O(\log L)\) времени, где $L$ --- количество элементов в бакете. Это значительно улучшает худший случай производительности до \(O(\log n)\), где $n$ --- общее количество элементов, по сравнению с \(O(n)\) при использовании линейного списка. Подход используется, например, в \texttt{java.util.HashMap} для бакетов с большим количеством элементов.
\end{itemize}
Выбор стратегии разрешения коллизий существенно влияет на компромисс между использованием памяти, производительностью операций в среднем и худшем случаях, а также сложностью реализации. Метод цепочек с простыми списками (или деками, как в вашем случае) является одним из самых простых в реализации, но его производительность в худшем случае деградирует до линейной.

\section{Анализ производительности и временной сложности}

Анализ временной сложности операций хеш-таблицы обычно рассматривается в двух аспектах: среднем и худшем случае. Это сильно зависит от качества хеш-функции и выбранной стратегии разрешения коллизий.

\subsection{Коэффициент заполнения (Load Factor)}

Коэффициент заполнения (\( \alpha \)) определяется как отношение количества элементов в таблице (\( n \)) к размеру массива бакетов (\( k \)).
\[ \alpha = \frac{n}{k} \]
В реализации с методом цепочек (как ваша), load factor может быть больше 1, так как каждый бакет может содержать несколько элементов. Высокий load factor означает, что в бакетах в среднем находится больше элементов, что увеличивает длину цепочек и, соответственно, время выполнения операций, требующих сканирования цепочки.

\subsection{Временная сложность операций}

Предполагая, что вычисление хеш-функции занимает константное время \(O(1)\) (что верно для большинства стандартных типов), временная сложность операций в вашей \texttt{sml::HashMap} с методом цепочек на основе \texttt{sml::Deque} определяется в основном временем поиска элемента внутри соответствующего дека.

\begin{itemize}
    \item \textbf{Insert:}
    \begin{itemize}
        \item \textit{Средний случай:} \(O(1)\). При равномерном распределении, средняя длина цепочки \(L = \alpha\). Поиск по деку занимает \(O(L)\), добавление в конец дека (\\texttt{push\_back}) --- \(O(1)\) (если \texttt{sml::Deque} эффективно реализован). Итого \(O(L)\). При низком \(\alpha\), это близко к \(O(1)\).
        \item \textit{Худший случай:} \(O(n)\). Все \(n\) элементов хешируются в один бакет. Поиск и добавление нового элемента требует сканирования дека размером \(n\).
    \end{itemize}
    \item \textbf{Remove:}
    \begin{itemize}
        \item \textit{Средний случай:} \(O(L)\). Поиск элемента \(O(L)\). Реализация удаления путем создания нового дека и копирования в него всех элементов, кроме удаляемого, требует \(O(L)\) времени. Итого \(O(L)\). При низком \(\alpha\), это близко к \(O(1)\).
        \item \textit{Худший случай:} \(O(n)\). Все \(n\) элементов в одном бакете. Поиск \(O(n)\), создание и заполнение временного дека --- \(O(n)\). Итого \(O(n)\).
    \end{itemize}
    \item \textbf{Find:}
    \begin{itemize}
        \item \textit{Средний случай:} \(O(L)\). Поиск по деку размером \(L\) занимает \(O(L)\). При низком \(\alpha\), это близко к \(O(1)\).
        \item \textit{Худший случай:} \(O(n)\). Все \(n\) элементов в одном бакете, требуется линейный поиск по деку размером \(n\).
    \end{itemize}
    \item \textbf{Print:} \(O(k + n)\). Требует итерации по всем \(k\) бакетам и всем \(n\) элементам.
    \item \textbf{Hash:} \(O(1)\) (для стандартных типов).
\end{itemize}

Важно отметить, что "средний случай" производительности сильно зависит от равномерности распределения хешей и, следовательно, от качества хеш-функции и выбора размера таблицы. При неудачной хеш-функции или плохом выборе \texttt{size\_} (например, степень двойки для целочисленных ключей), даже при небольшом load factor могут возникать "горячие" бакеты с большим количеством коллизий, приближая производительность к худшему случаю.

\subsection{Пространственная сложность}

Пространственная сложность \texttt{sml::HashMap}: \(O(k + n)\), где \(k\) --- размер массива бакетов (\texttt{size\_}), а \(n\) --- общее количество хранимых элементов. Память расходуется на сам массив бакетов (\texttt{k} указателей/объектов \texttt{Deque}) и на хранение \(n\) структур \texttt{Entry} внутри деков. В отличие от открытой адресации, метод цепочек может хранить больше элементов, чем бакетов (\(n > k\)), без необходимости обязательного изменения размера, но за счет увеличения длины цепочек.

\section{Возможности расширения и улучшения}

Текущая реализация хеш-таблицы, будучи учебной моделью, может быть значительно расширена и улучшена для повышения производительности, гибкости и соответствия стандартам продакшн-качества.

\subsection{Динамическое изменение размера (Рехеширование)}

\begin{lstlisting}[style=cpp]
// Пример реализации метода Resize
void Resize(int new_size) {
    // 1. Создаем новый массив бакетов большего размера.
    Deque<Entry>* new_buckets = new Deque<Entry>[new_size];
    
    // 2. Сохраняем старый массив бакетов для переноса элементов.
    Deque<Entry>* old_buckets = buckets_;
    int old_size = size_;
    
    // 3. Обновляем размер таблицы и указатель на бакеты.
    buckets_ = new_buckets;
    size_ = new_size;
    
    // 4. Перехеширование всех элементов из старых бакетов в новые.
    for (int i = 0; i < old_size; ++i) {
        // Итерируем по элементам в каждом старом бакете.
        for (size_t j = 0; j < old_buckets[i].size(); ++j) {
            Entry& entry = old_buckets[i][j];
            // Вычисляем новый индекс бакета с учетом нового размера.
            int new_index = std::hash<Key>{}(entry.key) % new_size;
            // Вставляем элемент в новый бакет.
            buckets_[new_index].push_back(entry);
        }
    }
    
    // 5. Освобождаем память старого массива бакетов.
    delete[] old_buckets;
}

// Пример использования в Insert для автоматического изменения размера
void Insert(const Key& key, const Value& value) {
    // Проверка необходимости изменения размера перед вставкой
    // Например, если load factor превышает пороговое значение (например, 0.7)
    if ((double)TotalElements() / size_ > 0.7) {
        Resize(size_ * 2); // Удваиваем размер
    }
    
    // ... существующий код вставки ...
}

// Необходим метод для подсчета общего количества элементов
int TotalElements() const {
    int count = 0;
    for (int i = 0; i < size_; ++i) {
        count += buckets_[i].size();
    }
    return count;
}
\end{lstlisting}
Внедрение механизма динамического изменения размера (рехеширования) при достижении определенного коэффициента заполнения (load factor). Это позволит поддерживать среднее время операций близким к \(O(1)\) даже при значительном росте количества элементов. Операция рехеширования требует создания нового, большего массива бакетов и перераспределения (повторного хеширования) всех существующих элементов по новым бакетам. Это дорогая операция \(O(n)\), но она выполняется достаточно редко, чтобы среднее время операций оставалось низким.

\subsection{Улучшенная хеш-функция}

Реализация или использование более сложной хеш-функции, которая обеспечивает более равномерное распределение ключей по бакетам для конкретного типа ключей и ожидаемого распределения данных. Это может включать использование криптографических хешей (хотя они медленнее) или специализированных хеш-функций, разработанных для минимизации коллизий в определенных сценариях.

\subsection{Различные стратегии разрешения коллизий}

Реализация альтернативных стратегий разрешения коллизий, таких как открытая адресация (линейное, квадратичное пробирование, двойное хеширование) или использование сбалансированных деревьев в качестве цепочек. Каждая стратегия имеет свои компромиссы по памяти, производительности и сложности реализации.

\subsection{Параметризация хеш-функции и компаратора ключей}

Модификация класса для принятия пользовательской хеш-функции и функции сравнения ключей (для проверки на равенство) в качестве шаблонных параметров или аргументов конструктора.

\begin{lstlisting}[style=cpp]
template <typename Key, typename Value, 
          typename Hash = std::hash<Key>, 
          typename KeyEqual = std::equal_to<Key>>
class HashMap {
 public:
  explicit HashMap(int size = 10, const Hash& hash = Hash(), const KeyEqual& equal = KeyEqual())
      : size_(size), hash_func_(hash), key_equal_(equal) {
    buckets_ = new Deque<Entry>[size_];
  }
  
  // ... использование hash_func_ и key_equal_ в методах ...
  
 private:
  Hash hash_func_;
  KeyEqual key_equal_;
  
  int Hash(const Key& key) const {
    return hash_func_(key) % size_;
  }
  
  // В методах Find, Insert, Remove использовать key_equal_
  // bool operator==(const Entry& other) const в Entry также должен использовать key_equal_
};
\end{lstlisting}
Это сделает \texttt{HashMap} более гибким и пригодным для использования с пользовательскими типами ключей без необходимости модификации самого класса \texttt{HashMap}.

\subsection{Реализация двусторонней хеш-таблицы (Bidirectional Map)}

Расширение функциональности для обеспечения эффективного поиска не только по ключу (\texttt{Key} -> \texttt{Value}), но и по значению (\texttt{Value} -> \texttt{Key}). Это может быть реализовано путем поддержания двух отдельных хеш-таблиц или более сложной внутренней структуры.

\subsection{Добавление итераторов}

Реализация поддержки стандартных итераторов (как показано в примере в оригинальной документации) для упрощения обхода всех элементов таблицы, совместимости с алгоритмами STL и более идиоматичного использования в C++.

\subsection{Обработка исключений и граничных случаев}

Добавление более надежной обработки ошибок, например, при доступе по неверному индексу бакета в \texttt{GetBucketSize} или \texttt{GetKeyAt}, или при неудачном выделении памяти.

\section{Заключение}

Реализованная \texttt{sml::HashMap} представляет собой фундаментальную структуру данных "хеш-таблица" с использованием метода цепочек на основе собственной реализации дека (\texttt{sml::Deque}) для разрешения коллизий. Данная работа является ценным учебным проектом, демонстрирующим базовые принципы хеширования, управления коллизиями и ручного управления памятью в C++.

Несмотря на ограничения, присущие фиксированному размеру таблицы и выбору специфической структуры для цепочек (Deque), реализация успешно выполняет базовые операции вставки, удаления и поиска. Подробный анализ методов и их временной сложности показывает, что средняя производительность операций при низком коэффициенте заполнения близка к константному времени \(O(1)\), однако в худшем случае она деградирует до линейной \(O(n)\).

Сравнение со \texttt{std::unordered\_map} выявило ключевые различия, в первую очередь в динамическом управлении размером, уровне оптимизации и соответствии стандартным интерфейсам. Предложенные возможности расширения, такие как автоматическое рехеширование, параметризация, поддержка итераторов и альтернативные стратегии коллизий, указывают пути для дальнейшего развития и улучшения данной базовой реализации, приближая ее к стандартам продакшн-качества и расширяя область ее применимости.

Данная документация предоставляет всестороннее описание структуры, реализации и анализа производительности \texttt{sml::HashMap}, служа основой для понимания принципов хешированных структур данных.

\end{document} 